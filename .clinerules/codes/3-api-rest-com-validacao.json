{
  "id": "3",
  "title": "API REST com Validação",
  "tech": "Python",
  "language": "python",
  "description": "API REST completa com FastAPI, validação e documentação automática",
  "content_type": "code",
  "card_type": "codigos",
  "screens": [
    {
      "name": "Models",
      "description": "Modelos Pydantic para validação de dados",
      "route": "cards/3/models",
      "order": 0,
      "blocks": [
        {
          "id": "a4a0b1f4-ee61-494f-b4fa-79af5aebe4bb",
          "type": "code",
          "title": "Models",
          "language": "python",
          "order": 0,
          "content": "from pydantic import BaseModel, EmailStr, validator\n        from typing import Optional, List\n        from datetime import datetime\n        from enum import Enum\n\n        class UserRole(str, Enum):\n            USER = \"user\"\n            ADMIN = \"admin\"\n            MODERATOR = \"moderator\"\n\n        class UserBase(BaseModel):\n            email: EmailStr\n            name: str\n            role: UserRole = UserRole.USER\n            \n            @validator('name')\n            def name_must_not_be_empty(cls, v):\n                if not v.strip():\n                    raise ValueError('Nome não pode estar vazio')\n                return v.strip()\n\n        class UserCreate(UserBase):\n            password: str\n            \n            @validator('password')\n            def password_validation(cls, v):\n                if len(v) < 6:\n                    raise ValueError('Senha deve ter pelo menos 6 caracteres')\n                return v\n\n        class UserUpdate(BaseModel):\n            email: Optional[EmailStr] = None\n            name: Optional[str] = None\n            role: Optional[UserRole] = None\n            \n            @validator('name')\n            def name_must_not_be_empty(cls, v):\n                if v is not None and not v.strip():\n                    raise ValueError('Nome não pode estar vazio')\n                return v.strip() if v else v\n\n        class UserResponse(UserBase):\n            id: int\n            created_at: datetime\n            updated_at: Optional[datetime] = None\n            \n            class Config:\n                from_attributes = True\n\n        class UserList(BaseModel):\n            users: List[UserResponse]\n            total: int\n            page: int\n            per_page: int\n            \n        class Token(BaseModel):\n            access_token: str\n            token_type: str = \"bearer\"\n            expires_in: int\n\n        class LoginRequest(BaseModel):\n            email: EmailStr\n            password: str"
        }
      ]
    },
    {
      "name": "Routes",
      "description": "Rotas da API com validação e documentação",
      "route": "cards/3/routes",
      "order": 1,
      "blocks": [
        {
          "id": "d08922c7-21ec-49c8-a650-670de0ba466e",
          "type": "code",
          "title": "Routes",
          "language": "python",
          "order": 0,
          "content": "from fastapi import APIRouter, Depends, HTTPException, status, Query\n        from fastapi.security import HTTPBearer\n        from sqlalchemy.orm import Session\n        from typing import List, Optional\n        import math\n\n        from .models import UserCreate, UserUpdate, UserResponse, UserList, LoginRequest, Token\n        from .database import get_db\n        from .auth import get_current_user, create_access_token, verify_password\n        from .crud import UserCRUD\n\n        router = APIRouter(prefix=\"/api/users\", tags=[\"users\"])\n        security = HTTPBearer()\n\n        @router.post(\"/register\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\n        async def register_user(\n            user_data: UserCreate,\n            db: Session = Depends(get_db)\n        ):\n            \"\"\"\n            Registra um novo usuário no sistema.\n            \n            - **email**: Email único do usuário\n            - **name**: Nome completo do usuário\n            - **password**: Senha com pelo menos 6 caracteres\n            - **role**: Role do usuário (user, admin, moderator)\n            \"\"\"\n            # Verificar se email já existe\n            if UserCRUD.get_by_email(db, user_data.email):\n                raise HTTPException(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    detail=\"Email já cadastrado\"\n                )\n            \n            user = UserCRUD.create(db, user_data)\n            return user\n\n        @router.post(\"/login\", response_model=Token)\n        async def login(\n            login_data: LoginRequest,\n            db: Session = Depends(get_db)\n        ):\n            \"\"\"\n            Autentica um usuário e retorna um token de acesso.\n            \"\"\"\n            user = UserCRUD.get_by_email(db, login_data.email)\n            if not user or not verify_password(login_data.password, user.password_hash):\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Credenciais inválidas\"\n                )\n        \n            access_token = create_access_token(data={\"sub\": str(user.id)})\n            return {\n                \"access_token\": access_token,\n                \"token_type\": \"bearer\",\n                \"expires_in\": 3600\n            }\n\n        @router.get(\"/\", response_model=UserList)\n        async def list_users(\n            page: int = Query(1, ge=1, description=\"Número da página\"),\n            per_page: int = Query(10, ge=1, le=100, description=\"Itens por página\"),\n            search: Optional[str] = Query(None, description=\"Buscar por nome ou email\"),\n            role: Optional[str] = Query(None, description=\"Filtrar por role\"),\n            current_user = Depends(get_current_user),\n            db: Session = Depends(get_db)\n        ):\n            \"\"\"\n            Lista usuários com paginação e filtros.\n            \n            Requer autenticação.\n            \"\"\"\n            users, total = UserCRUD.get_multi(\n                db, \n                skip=(page - 1) * per_page,\n                limit=per_page,\n                search=search,\n                role=role\n            )\n            \n            return UserList(\n                users=users,\n                total=total,\n                page=page,\n                per_page=per_page\n            )\n\n        @router.get(\"/{user_id}\", response_model=UserResponse)\n        async def get_user(\n            user_id: int,\n            current_user = Depends(get_current_user),\n            db: Session = Depends(get_db)\n        ):\n            \"\"\"\n            Busca um usuário específico por ID.\n            \"\"\"\n            user = UserCRUD.get(db, user_id)\n            if not user:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=\"Usuário não encontrado\"\n                )\n            return user\n\n        @router.put(\"/{user_id}\", response_model=UserResponse)\n        async def update_user(\n            user_id: int,\n            user_data: UserUpdate,\n            current_user = Depends(get_current_user),\n            db: Session = Depends(get_db)\n        ):\n            \"\"\"\n            Atualiza dados de um usuário.\n            \n            Apenas o próprio usuário ou admins podem atualizar.\n            \"\"\"\n            user = UserCRUD.get(db, user_id)\n            if not user:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=\"Usuário não encontrado\"\n                )\n            \n            # Verificar permissões\n            if current_user.id != user_id and current_user.role != \"admin\":\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=\"Sem permissão para atualizar este usuário\"\n                )\n            \n            updated_user = UserCRUD.update(db, user_id, user_data)\n            return updated_user\n\n        @router.delete(\"/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\n        async def delete_user(\n            user_id: int,\n            current_user = Depends(get_current_user),\n            db: Session = Depends(get_db)\n        ):\n            \"\"\"\n            Remove um usuário do sistema.\n            \n            Apenas admins podem deletar usuários.\n            \"\"\"\n            if current_user.role != \"admin\":\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=\"Apenas admins podem deletar usuários\"\n                )\n            \n            user = UserCRUD.get(db, user_id)\n            if not user:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=\"Usuário não encontrado\"\n                )\n            \n            UserCRUD.delete(db, user_id)\n            return None"
        }
      ]
    },
    {
      "name": "CRUD",
      "description": "Operações de banco de dados",
      "route": "cards/3/crud",
      "order": 2,
      "blocks": [
        {
          "id": "a8a09d59-b511-4705-80d1-d5f508c634a7",
          "type": "code",
          "title": "CRUD",
          "language": "python",
          "order": 0,
          "content": "from sqlalchemy.orm import Session\n        from sqlalchemy import and_, or_\n        from typing import List, Optional, Tuple\n        from passlib.context import CryptContext\n\n        from .database import User as UserModel\n        from .models import UserCreate, UserUpdate\n\n        pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n        class UserCRUD:\n            @staticmethod\n            def get_password_hash(password: str) -> str:\n                return pwd_context.hash(password)\n            \n            @staticmethod\n            def create(db: Session, user_data: UserCreate) -> UserModel:\n                \"\"\"Cria um novo usuário\"\"\"\n                password_hash = UserCRUD.get_password_hash(user_data.password)\n                \n                db_user = UserModel(\n                    email=user_data.email,\n                    name=user_data.name,\n                    role=user_data.role,\n                    password_hash=password_hash\n                )\n                \n                db.add(db_user)\n                db.commit()\n                db.refresh(db_user)\n                return db_user\n            \n            @staticmethod\n            def get(db: Session, user_id: int) -> Optional[UserModel]:\n                \"\"\"Busca usuário por ID\"\"\"\n                return db.query(UserModel).filter(UserModel.id == user_id).first()\n            \n            @staticmethod\n            def get_by_email(db: Session, email: str) -> Optional[UserModel]:\n                \"\"\"Busca usuário por email\"\"\"\n                return db.query(UserModel).filter(UserModel.email == email).first()\n            \n            @staticmethod\n            def get_multi(\n                db: Session,\n                skip: int = 0,\n                limit: int = 10,\n                search: Optional[str] = None,\n                role: Optional[str] = None\n            ) -> Tuple[List[UserModel], int]:\n                \"\"\"Lista usuários com filtros e paginação\"\"\"\n                query = db.query(UserModel)\n                \n                # Aplicar filtros\n                filters = []\n                \n                if search:\n                    search_filter = or_(\n                        UserModel.name.ilike(f\"%{search}%\"),\n                        UserModel.email.ilike(f\"%{search}%\")\n                    )\n                    filters.append(search_filter)\n                \n                if role:\n                    filters.append(UserModel.role == role)\n                \n                if filters:\n                    query = query.filter(and_(*filters))\n                \n                # Contar total\n                total = query.count()\n                \n                # Aplicar paginação\n                users = query.offset(skip).limit(limit).all()\n                \n                return users, total\n            \n            @staticmethod\n            def update(db: Session, user_id: int, user_data: UserUpdate) -> Optional[UserModel]:\n                \"\"\"Atualiza dados do usuário\"\"\"\n                db_user = UserCRUD.get(db, user_id)\n                if not db_user:\n                    return None\n                \n                update_data = user_data.dict(exclude_unset=True)\n                \n                for field, value in update_data.items():\n                    setattr(db_user, field, value)\n                \n                db.commit()\n                db.refresh(db_user)\n                return db_user\n            \n            @staticmethod\n            def delete(db: Session, user_id: int) -> bool:\n                \"\"\"Remove usuário\"\"\"\n                db_user = UserCRUD.get(db, user_id)\n                if not db_user:\n                    return False\n                \n                db.delete(db_user)\n                db.commit()\n                return True\n            \n            @staticmethod\n            def update_last_login(db: Session, user_id: int) -> None:\n                \"\"\"Atualiza último login do usuário\"\"\"\n                from datetime import datetime\n                \n                db_user = UserCRUD.get(db, user_id)\n                if db_user:\n                    db_user.last_login = datetime.utcnow()\n                    db.commit()\n            \n            @staticmethod\n            def get_active_users(db: Session) -> List[UserModel]:\n                \"\"\"Retorna usuários ativos (logaram nos últimos 30 dias)\"\"\"\n                from datetime import datetime, timedelta\n                \n                thirty_days_ago = datetime.utcnow() - timedelta(days=30)\n                \n                return db.query(UserModel).filter(\n                    UserModel.last_login >= thirty_days_ago\n                ).all()\n            \n            @staticmethod\n            def count_by_role(db: Session) -> dict:\n                \"\"\"Conta usuários por role\"\"\"\n                from sqlalchemy import func\n                \n                result = db.query(\n                    UserModel.role,\n                    func.count(UserModel.id).label('count')\n                ).group_by(UserModel.role).all()\n                \n                return {role: count for role, count in result}"
        }
      ]
    }
  ]
}